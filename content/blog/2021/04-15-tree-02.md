---
title: "[ìë£Œêµ¬ì¡°] Tree 02"
date: 2021-04-15
tags:
  - ìë£Œêµ¬ì¡°
  - algorithm
  - javascript
---

## BST ì‚­ì œ

ë§¤ìš° ë³µì í•˜ë¯€ë¡œ, **ê²½ìš°ë¥¼ ë‚˜ëˆ„ì–´ì„œ ì´í•´í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤**

### Leaf Node ì‚­ì œ

- Leaf Node: Child Nodeê°€ ì—†ëŠ” Node
- ì‚­ì œí•  Nodeì˜ Parent Nodeê°€ ì‚­ì œí•  Nodeë¥¼ ê°€ë¦¬í‚¤ì§€ ì•Šë„ë¡ í•œë‹¤.

### Child Nodeê°€ í•˜ë‚˜ì¸ Node ì‚­ì œ

- ì‚­ì œí•  Nodeì˜ Parent Nodeê°€ ì‚­ì œí•  Nodeì˜ Child Nodeë¥¼ ê°€ë¦¬í‚¤ë„ë¡ í•œë‹¤.

### Child Nodeê°€ ë‘ ê°œì¸ Node ì‚­ì œ

1.  **ì‚­ì œí•  Nodeì˜ ì˜¤ë¥¸ìª½ ìì‹ ì¤‘, ê°€ì¥ ì‘ì€ ê°’ì„ ì‚­ì œí•  Nodeì˜ Parent Nodeê°€ ê°€ë¦¬í‚¤ë„ë¡ í•œë‹¤.**
2.  ì‚­ì œí•  Nodeì˜ ì™¼ìª½ ìì‹ ì¤‘, ê°€ì¥ í° ê°’ì„ ì‚­ì œí•  Nodeì˜ Parent Nodeê°€ ê°€ë¦¬í‚¤ë„ë¡ í•œë‹¤.

1ë²ˆì´ë‚˜ 2ë²ˆì´ë‚˜ ê²°ê³¼ì ìœ¼ë¡  ë¹„ìŠ·í•˜ë¯€ë¡œ 1ë²ˆ ìœ„ì£¼ë¡œ ì„¤ëª…

**1ë²ˆ ë°©ì‹ì„ ì´ìš©í•œ ì‚­ì œ ì‹œë‚˜ë¦¬ì˜¤**

1.  ì‚­ì œí•  Nodeì˜ ì˜¤ë¥¸ìª½ ìì‹ ì„ íƒ
2.  ì˜¤ë¥¸ìª½ ìì‹ì˜ ê°€ì¥ ì™¼ìª½ì— ìˆëŠ” Nodeë¥¼ ì„ íƒ
3.  í•´ë‹¹ Nodeë¥¼ ì‚­ì œí•  Nodeì˜ Parent Nodeì˜ ì™¼ìª½ Branchê°€ ê°€ë¦¬í‚¤ê²Œ í•¨
4.  í•´ë‹¹ Nodeì˜ ì™¼ìª½ Branchê°€ ì‚­ì œí•  Nodeì˜ ì™¼ìª½ Child Nodeë¥¼ ê°€ë¦¬í‚¤ê²Œ í•¨
5.  í•´ë‹¹ Nodeì˜ ì˜¤ë¥¸ìª½ Branchê°€ ì‚­ì œí•  Nodeì˜ ì˜¤ë¥¸ìª½ Child Nodeë¥¼ ê°€ë¦¬í‚¤ê²Œ í•¨
6.  ë§Œì•½ í•´ë‹¹ Node(ê°€ì¥ ì™¼ìª½ Node)ê°€ ì˜¤ë¥¸ìª½ Child Nodeë¥¼ ê°€ì§€ê³  ìˆì„ ê²½ìš°ì—ëŠ”, í•´ë‹¹ Nodeì˜ ë³¸ë˜ Parent Node(ê°€ì¥ ì™¼ìª½ Nodeì˜ Parent Node)ì˜ ì™¼ìª½ Branchê°€ í•´ë‹¹ Nodeì˜ ì˜¤ë¥¸ìª½ Child Nodeë¥¼ ê°€ë¦¬í‚¤ê²Œ í•¨

### BST ì‚­ì œ ì½”ë“œ êµ¬í˜„ê³¼ ë¶„ì„

**ì‚­ì œí•  Node íƒìƒ‰**

- ì‚­ì œí•  Nodeê°€ ì—†ëŠ” ê²½ìš°ë„ ì²˜ë¦¬í•´ì•¼ í•¨
  - ì´ë¥¼ ìœ„í•´ ì‚­ì œí•  Nodeê°€ ì—†ëŠ” ê²½ìš°ëŠ” `false`ë¥¼ ë¦¬í„´í•˜ê³ , í•¨ìˆ˜ë¥¼ ì¢…ë£Œ ì‹œí‚´

```javascript
class Node {
  value;
  left;
  right;
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class NodeManagement {
  head;
  constructor(head) {
    this.head = head;
  }
  insert(value) {
    let currentNode = this.head;

    while (true) {
      if (value < currentNode.value) {
        if (currentNode.left) {
          currentNode = currentNode.left;
        } else {
          currentNode.left = new Node(value);
          return;
        }
      } else {
        if (currentNode.right) {
          currentNode = currentNode.right;
        } else {
          currentNode.right = new Node(value);
          return;
        }
      }
    }
  }
  search(value) {
    let currentNode = this.head;
    while (currentNode) {
      if (currentNode.value === value) {
        return currentNode;
      } else {
        currentNode =
          currentNode.value > value ? currentNode.left : currentNode.right;
      }
    }

    return null;
  }
  delete(value) {
    let searched = false;
    let currentNode = this.head;
    let parentNode = this.head;
    while (currentNode) {
      if (currentNode.value === value) {
        searched = true;
        break;
      } else {
        parentNode = currentNode;
        currentNode =
          currentNode.value > value ? currentNode.left : currentNode.right;
      }
    }
    if (!searched) {
      return searched;
    }

    if (currentNode.left && currentNode.right) {
      // case 1: ì‚­ì œí•  ë…¸ë“œê°€ child Nodeê°€ ë‘ê°œ ì „ë¶€ ìˆëŠ” Node ì¼ë•Œ

      let changeNode = currentNode.right;
      let changeNodeParent = currentNode.right;

      while (changeNode.left) {
        changeNodeParent = changeNode;
        changeNode = changeNode.left;
      }

      changeNodeParent.left = null;

      if (changeNode.right) {
        changeNodeParent.left = changeNode.right;
      }
      value < parentNode.value
        ? (parentNode.left = changeNode)
        : (parentNode.right = changeNode);
      changeNode.left = currentNode.left;
      changeNode.right = currentNode.right;
    } else if (currentNode.left || currentNode.right) {
      // case 2: ì‚­ì œí•  ë…¸ë“œê°€ child Nodeê°€ í•˜ë‚˜ ë¿ì¸ Node ì¼ë•Œ
      const childNode = currentNode.left || currentNode.right;
      parentNode.value > value
        ? (parentNode.left = childNode)
        : (parentNode.right = childNode);
    } else {
      // case 3: ì‚­ì œí•  ë…¸ë“œê°€ leaf(terminal) Node ì¼ë•Œ
      parentNode.value > value
        ? (parentNode.left = null)
        : (parentNode.right = null);
    }
  }
}

const head = new Node(30);
const BST = new NodeManagement(head);

BST.insert(15);
BST.insert(13);
BST.insert(11);
BST.insert(14);
BST.insert(18);
BST.insert(16);
BST.insert(19);
BST.insert(17);

BST.delete(15);

console.log(BST.search(16));
```

# BSTì˜ ì‹œê°„ ë³µì¡ë„ì™€ ë‹¨ì 

## ì‹œê°„ ë³µì¡ë„(íƒìƒ‰ì‹œ)

- depth(íŠ¸ë¦¬ì˜ ë†’ì´)ë¥¼ hë¼ê³  í‘œê¸°í•œë‹¤ë©´, O(h)
- nê°œì˜ ë…¸ë“œë¥¼ ê°€ì§„ë‹¤ë©´, h = log2â€Šn ì— ê°€ê¹Œì›€ -> ì‹œê°„ë³µì¡ë„ëŠ” O(logn)
  í•œë²ˆ ì‹¤í–‰ì‹œë§ˆë‹¤, 50%ì˜ ì‹¤í–‰ì‹œê°„ì„ ë‹¨ì¶• ì‹œí‚¬ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•¨

## ë‹¨ì 

í‰ê·  ì‹œê°„ ë³µì¡ë„ëŠ” O(logn) ì´ì§€ë§Œ, ìµœì•…ì˜ ê²½ìš°ëŠ” linked list ë“±ê³¼ ë™ì¼í•œ ì„±ëŠ¥ì„ ë³´ì—¬ì¤Œ(O(n))

---

ì´ë²ˆì— ì‹œê°„ ì œì¼ ë§ì´ ì¼ë„¤.. ğŸ‘€
